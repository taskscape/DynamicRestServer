# Introduction

The purpose of this solution is to give an statup point in which an API with basic CRUD operation to each table of database is generated by knowing only connection 
string to the provided database. At this time we support only MS SQL and PostgreSQL.

# Getting Started

To run this solution you will need to:

* register an Azure Ad application ([App registrations](https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/RegisteredApps)). Example application manifest: [Manifest.json](Manifest.json)
* have an Azure Table Storage account ([Storage accounts](https://portal.azure.com/#blade/HubsExtension/BrowseResource/resourceType/Microsoft.Storage%2FStorageAccounts))
* fill required entries in appsettings.json (secrets.json in local development would be better):
    * information about registered application in Azure Ad
    * database connection string from which rest API will be generated
    * Azure Table Storage connection string and table name which is used to storage authorization permissions for each table and role from system

# Continuous integration

After commit and push to the main branch the solution is being automatically builded on Azure DevOps using the pipeline template [azure-pipelines.yml](azure-pipelines.yml)

# Continuous Deployment

After successful build on Azure Devops, solution is being deployed using produced artifact.

# How it works?

Solution is splitted into projects:
* Dynamic.Api - entry point with generated rest API
* Dynamic.DAL - data access layer with authorization entities, repositories, database seeder
* Dynamic.DbScaffolder - the heart of the solution resposible for scaffold provided database into entity framework core database model
* Dynamic.Services - business logic layer, dtos mappings
* Dynamic.Shared - handles solution cross-cutting concerns

When the Api starts the DbScaffolder scaffolds database using Entity Framework Core ScaffoldModel method, creates DbContext and generates dtos from exported types
using roslyn compiler. After that authorization database is filled up with permissions and also that permissions are being stored in memory cache for better performance. Auth db contains information about which role 
has access to perform operation on particular table.

**Operations (http methods):**

* GET
* POST
* PUT
* DELETE

**Default permissions for roles:**

* Admin - all tables, all method
* User - GET, POST, PUT
* Guest - GET

Next the controllers are being created using [GenericController.cs](src/Dynamic.Api/Controllers/GenericController.cs) which contains methods:

* GetPagedResultAsync
* BrowseAsync
* GetAsync
* AddAsync
* UpdateAsync
* DeleteAsync

All methods are virtual and can be overridden in custom controller.

## Authentication and Authorization

Api is using oauth2 implemented in library [Microsoft.Identity.Web](https://github.com/AzureAD/microsoft-identity-web) to authenticate requests. If request has valid access token there is also check if user has permission.
to perform the request ([PermissionHandler.cs](src/Dynamic.Api/Authorization/PermissionHandler.cs)).

On top af that lives swagger with UI, which can be used to perform actions. 